#!/usr/bin/env python3
"""This module provides package management functionality for MaRDI"""
# standard imports
import os
import sys
import time
import itertools
import signal
import subprocess
import tempfile
import argparse
import concurrent.futures
from math import log10, floor

# third party imports
import tomli
import gi
from progress.bar import Bar
from tusclient import client, exceptions
from tusclient.storage import filestorage
gi.require_version("OSTree", "1.0")
from gi.repository import OSTree, GLib

VERSION = '0.4-dev'
BWRAP_DEFAULT = f"{os.getenv('HOME')}/.var/org.mardi.maps/deps/bubblewrap/_builddir/bwrap"
if os.getenv('BWRAP_CMD') is not None:
    BWRAP = str(os.getenv('BWRAP_CMD'))
else:
    BWRAP = BWRAP_DEFAULT
OSTREE_REPO_MODE_BARE_USER = 2
SPINNER = itertools.cycle(['-', '\\', '|', '/'])
HOME = os.getenv('HOME')
KEEP_FREE_SPACE = 3
VERBOSE = False
OG_SIGINT_HANLDER = signal.getsignal(signal.SIGINT)
TUSTARGET = "http://0.0.0.0:8080"
if os.getenv("MAPS_UPLOAD_SERVER") is not None:
    TUSTARGET = str(os.getenv("MAPS_UPLOAD_SERVER"))
AUTH = os.getenv("MTDAUTH")


# Define a CLI
def addCLI():
    """Function adds a CLI to the package."""
    parser = argparse.ArgumentParser(
        prog='maps',
        description=("maps - MaRDI Packaging System : "
                     "Provides a unified interface for packaging "
                     "and deploying software environments."
                     ),
    )
    subparser = parser.add_subparsers(help="Use --help with each of the commands for more help ",
                                      dest="SubPars_NAME")
    # arguments for "main" path
    parser.add_argument('--version', action='version', version=VERSION)

    parser_runtime = subparser.add_parser("runtime",
                                          help="Command for deploying and executing runtimes")
    parser_runtime.add_argument('--command', dest='COMMAND', action='store',
                                default=False, help="Override for the command to run")
    parser_runtime.add_argument('-d', '--deploy', dest='DEPLOY', action='store',
                                default=False, help="deploy mode, for installing environments")
    parser_runtime.add_argument('-l', '--list', dest='LIST', action='store_true',
                                default=False, help="List available environments")
    parser_runtime.add_argument('--list-local', dest='LIST_LOCAL', action='store_true',
                                default=False, help="List available environments")
    parser_runtime.add_argument('--repo', dest='REPO', help="Repository to use")
    parser_runtime.add_argument('--reset', dest='RESET', action='store',
                                default=False, help="Reset the runtime.")
    parser_runtime.add_argument('-r', '--run', dest='RUN', action='store',
                                default=False, help="Which runtime to play.")
    parser_runtime.add_argument('-u', '--uninstall', dest='UNINSTALL', action='store',
                                default=False, help="Uninstall a runtime")
    parser_runtime.add_argument('--update', dest="UPDATE", action='store',
                                default=False, help="Update a runtime")
    parser_runtime.add_argument('-v', '--verbose', dest='VERBOSE', action='store_true',
                                help="enable verbose output")

    # arguments for remote management
    parser_remote = subparser.add_parser("remote",
                                         help="Command to add, delete, or list available remotes")
    parser_remote.add_argument('--add-remote', dest='REMOTE', nargs=2,
                               metavar=("REMOTE_NAME", "REMOTE_URL"), action='store',
                               default=False, help="Add REMOTE to local ostree repo")
    parser_remote.add_argument('--del-remote', dest="DEL_REMOTE", action='store',
                               default=False, help="Delete REMOTE from local ostree repo")
    parser_remote.add_argument('--list', dest="LIST", action='store_true',
                               default=False, help="List configured remotes")
    parser_remote.add_argument('--repo', dest='REPO', help="Repository to use")
    parser_remote.add_argument('-v', '--verbose', dest='VERBOSE', action='store_true',
                               help="enable verbose output")

    # arguments for packaging
    parser_pack = subparser.add_parser("package",
                                       help="Package mode, for creating runtimes")
    parser_pack.add_argument('-c', '--commit', dest='COMMIT', nargs=2, metavar=("TREE", "BRANCH"),
                             default=False, help="Commit TREE to BRANCH in REPO")
    parser_pack.add_argument('-i', '--initialize', dest='DIR',
                             help="initialize DIR with a good base tree")
    parser_pack.add_argument('-s', '--sandbox', dest='LOCATION',
                             help="Start a sandbox at LOCATION")
    parser_pack.add_argument('-v', '--verbose', dest='VERBOSE', action='store_true',
                             help="enable verbose output")
    parser_pack.add_argument('--repo', dest='REPO', help="Repository to use")
    parser_pack.add_argument('-u', '--upload', dest='UPLOAD', metavar="RUNTIME", action='store',
                             default=False, help="Upload RUNTIME for publishing.")

    return parser, parser_runtime, parser_remote, parser_pack


def sanity_checks(parsers):
    """Some simple sanity checks, before the program proceeds"""
    if len(sys.argv) == 1:
        parsers[0].print_help()
        sys.exit(1)

    if len(sys.argv) == 2:
        if "runtime" in sys.argv:
            parsers[1].print_help()
        elif "remote" in sys.argv:
            parsers[2].print_help()
        elif "package" in sys.argv:
            parsers[3].print_help()
        sys.exit(1)


def program_init(repopath):
    """Init function verifies requirements, sets up the repo. Returns the OSTree Repo."""
    opt1 = "-q"
    opt2 = "1>/dev/null"
    opt3 = ""
    if VERBOSE:
        opt1 = ""
        opt2 = ""
        opt3 = "-v"
        print("Ensuring bubblewrap exists...")
    # step 1 : check bwrap is installed
    if (BWRAP == BWRAP_DEFAULT) and not os.path.isfile(BWRAP):
        print("Bubblewrap was not found, and is being automatically installed....")
        # bubblewrap directory exists
        # try cd and get fetch
        if os.path.isdir(BWRAP[0:-15]):
            if VERBOSE:
                print("Bubblewrap directory found. Refreshing...")
            subprocess.run(f"cd {BWRAP[0:-15]} && git fetch {opt1} --all --prune && git checkout "
                           f"{opt1} --force ak/sigint && git reset {opt1} --hard ak/sigint",
                           shell=True, check=True)
            if VERBOSE:
                print("Deleting _builddir...")
            subprocess.run(f"rm -rf {opt3} {BWRAP[0:-15]}/_builddir".split(), check=True)
        # bubblewrap directory does not exist
        # clone bubblewrap
        else:
            if VERBOSE:
                print("Cloning bubblewrap...")
            subprocess.run(f"git clone {opt1} https://github.com/aaruni96/bubblewrap.git "
                           f"{BWRAP[0:-15]}", shell=True, check=False)
            subprocess.run(f"cd {BWRAP[0:-15]} && git checkout {opt1} ak/sigint", shell=True,
                           check=True)
        # compile bwrap
        if VERBOSE:
            print("Compiling bubblewrap...")
        subprocess.run(f"cd {BWRAP[0:-15]} && meson _builddir {opt2} "
                       f"&& meson compile -C _builddir {opt2}", shell=True, check=False)
        print("Bubblewrap installed!")
    assert os.path.isfile(BWRAP)
    if VERBOSE:
        print("Bubblewrap okay!")
    # step 2 : create the directory
    if VERBOSE:
        print("Ensuring ostree repo directory exists...")
        opts = "-pv"
    else:
        opts = "-p"
    subprocess.run(f"mkdir {opts} {'/'.join(repopath.split('/'))}".split(), check=True)

    # step 3 : Configure a good known remote, if not already present
    repo = repopath.split('/')[-1]
    repopath = '/'.join(repopath.split('/')[0:-1])
    config_path = f"{repopath}/repo/config"
    config_exists = os.path.isfile(config_path)
    fd = os.open(repopath, os.O_RDONLY)
    repo = OSTree.Repo.create_at(fd, repo, OSTree.RepoMode(OSTREE_REPO_MODE_BARE_USER),
                                 GLib.Variant('a{sv}', {}), None)
    # if we just created a repo (and thus config), configure how we reserve free space
    if not config_exists:
        if VERBOSE:
            print("Just created repo, configuring free space parameters...")
        with open(config_path, 'a', encoding="utf-8") as fo:
            fo.write(f'min-free-space-size={KEEP_FREE_SPACE}GB\n')
        repo.reload_config()
    if (not repo.remote_list()) or "Official" not in repo.remote_list():
        if VERBOSE:
            print("Automatically adding official remote")
        repo.remote_add("Official", "https://repo.oscar-system.org/",
                        GLib.Variant('a{sv}', {"gpg-verify": GLib.Variant('b', False)}),
                        None)
    return repo


def make_remote_ref_list(repo, remote):
    """Given a repo and a remote, return a list of refs in the remote of that repo"""
    if remote is None:
        return []
    if repo.remote_list() is None:
        print(f"Repo {repo} has no remotes!")
        return []
    if repo.remote_list() is not None:
        if remote not in repo.remote_list():
            print(f"Repo {repo} has no remote {remote}!")
            return []
    remote_refs = []
    try:
        remote_refs.extend(list(repo.remote_list_refs(remote)[1].keys()))
    except GLib.Error as e:
        print(f"Error in make_remote_ref_list:\n\n\t{e}.\n\nCould not fetch remotes. "
              "Reporting local refs only. ")
        return []
    return remote_refs


def mode_list(repo):
    """Prints a list of available refs"""
    print("Available runtimes are :")
    refs = list(repo.list_refs()[1].keys())
    if refs:
        print("Local")
        for ref in sorted(refs):
            print(f"\t - {ref}")
    remotes = repo.remote_list()
    for remote in remotes:
        remote_refs = make_remote_ref_list(repo, remote)
        if remote_refs:
            print(remote)
            for ref in sorted(remote_refs):
                print(f"\t - {ref}")


def mode_remotes(repo, args):
    """Administrative mode for remotes of the repo"""
    if args.LIST is not False:
        for remote in repo.remote_list():
            print(f"{remote}: {repo.remote_get_url(remote)[1]}")
        return
    if args.REMOTE is not False:
        repo.remote_add(args.REMOTE[0], args.REMOTE[1],
                        GLib.Variant('a{sv}', {"gpg-verify": GLib.Variant('b', False)}), None)
        print(f"Added {args.REMOTE} to list of remotes!")
        return
    if args.DEL_REMOTE is not False:
        repo.remote_delete(args.DEL_REMOTE)
        print(f"Deleted {args.DEL_REMOTE} from list of remotes!")
        return


def disambiguate_runtime(repo: OSTree.Repo, rrstring: str, installed: bool = True):
    """Tries to disambiguate input into remote:runtime."""
    if ':' in rrstring:
        remote, runtime = rrstring.split(':')
        if VERBOSE:
            print(f"Remote explicitly specified as {remote}.")
        return remote, runtime

    # if not, check all repo / runtimes to find a unique set
    if VERBOSE:
        print("Remote not explicitly specified. Attempting to disambiguate...")
    found = False
    remote = ''
    runtime = ''

    if not installed:
        # installed should be false for things like depoly
        # so we search *everywhere*, even in the local repository
        # this is to address the edge case when something is fetched into the local repo
        # but not checked out to user filesystem yet
        installed_runtimes = repo.list_refs()[1].keys()
        for i in installed_runtimes:
            if rrstring == i.split(':')[-1]:
                if found:
                    print(f"Could not disambiguate {rrstring}!\nFound in at least two remotes "
                          f"{remote} and {i.split(':')[0]}, maybe more! Please spicfy your runtime "
                          f"in the form \n\n\tremote:runtime\n\nFor example\n\n\t{remote}:{runtime}"
                          "\n")
                    sys.exit(1)
                else:
                    found = True
                    remote, runtime = i.split(':')

        if found:
            # found something with the same name installed, assume we want that, with a warning
            print(f"warning, possibly ambigious name. Assuming {runtime}")
            return runtime.split(':')

        # all known remotes
        remotes = repo.remote_list()
        for sremote in remotes:
            remote_refs = make_remote_ref_list(repo, sremote)
            if remote_refs:
                for ref in sorted(remote_refs):
                    if rrstring == ref:
                        # found a target
                        if not found:
                            found = True
                            remote = sremote
                        else:
                            print(f"Could not disambiguate {rrstring}!\nFound in at least two "
                                  f"remotes {remote} and {sremote}, maybe more! Please specify your"
                                  " runtime in the form \n\n\tremote:runtime\n\nFor example\n\n\t"
                                  f"{remote}:{rrstring}\n")
                            sys.exit(1)
        if found:
            if VERBOSE:
                print(f"Disambiguated {rrstring} into {remote}:{runtime}!")
            return remote, runtime

        print(f"Unable to disambiguate {rrstring}! Returning garbage...")
        return ["notfound", "notfound"]
    # else installed is true
    # so we are disambiguating for run
    # search only in the installed runtimes
    # error if we don't find anything
    installed_runtimes = repo.list_refs()[1].keys()
    for i in installed_runtimes:
        if rrstring == i.split(':')[-1]:
            if found:
                print(f"Could not disambiguate {rrstring}!\nFound in at least two remotes "
                      f"{remote} and {i.split(':')[0]}, maybe more! Please spicfy your runtime "
                      f"in the form \n\n\tremote:runtime\n\nFor example\n\n\t{remote}:{runtime}"
                      "\n")
                sys.exit(1)
            else:
                found = True
                remote, runtime = i.split(':')
    if found:
        if VERBOSE:
            print(f"Disambiguated {rrstring} into {remote}:{runtime}!")
        return remote, runtime

    print(f"Unable to disambiguate {rrstring}! Returning garbage...")
    return ["notfound", "notfound"]


def mode_run(repo, args):
    """Function to execute a deployed environment"""

    remote, runtime = disambiguate_runtime(repo, args.RUN, installed=True)

    # check if the path exists
    DATADIR = f"{os.getenv('HOME')}/.var/org.mardi.maps/{remote}/{runtime}"
    if VERBOSE:
        print(f"Attempting to run {DATADIR}...")
    if not os.path.isdir(DATADIR):
        raise AssertionError(f"Data directory does not exist. Is {remote}:{runtime} installed"
                             " ?")

    # ensure share source and targets exist
    if VERBOSE:
        print("Making sure Public directories exist...")
        opts = '-pv'
    else:
        opts = '-p'
    subprocess.run(f"mkdir {opts} {os.getenv('HOME')}/Public".split(), check=True)

    # check for manifest file
    if os.path.isfile(f"{DATADIR}/rwfs/manifest.toml"):
        with open(f"{DATADIR}/rwfs/manifest.toml", 'rb') as manifest_file:
            command = tomli.load(manifest_file)
            command = command['Core']["command"]
    elif os.path.isfile(f"{DATADIR}/rofs/manifest.toml"):
        with open(f"{DATADIR}/rofs/manifest.toml", 'rb') as manifest_file:
            command = tomli.load(manifest_file)
            command = command['Core']["command"]
    else:
        command = "bash --norc"
    if args.COMMAND:
        command = args.COMMAND
    if command == '':
        raise ValueError
    # launch sandbox
    print(f"Launching {remote}:{runtime}...")
    senv = os.environ
    senv["HOME"] = "/home/runtime"
    senv["PS1"] = "\\u@runtime:\\w# "
    senv["LC_ALL"] = "C"
    # ignore SIGINT
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    rstatus = subprocess.run((f"{BWRAP} --forward-signals --unshare-user --unshare-pid "
                              f"--overlay-src {DATADIR}/rofs --overlay {DATADIR}/rwfs "
                              f"{DATADIR}/tmpfs /  --bind {HOME}/Public {senv['HOME']}/Public "
                              f"--ro-bind /sys /sys --die-with-parent --proc /proc --dev /dev "
                              f"--uid 0 --gid 0 {command}").split(), env=senv,
                             check=False)
    if rstatus.returncode != 0:
        print(f"Sandbox exited with return code {rstatus.returncode}")
    elif VERBOSE:
        print("Sandbox exited successfully!")
    # stop ignoring SIGINT
    signal.signal(signal.SIGINT, OG_SIGINT_HANLDER)


def download(repopath, remote, target):
    """Function to download a repo from remote"""

    subprocess.run(f"ostree --repo={repopath} pull '{remote}:{target}'", check=True, shell=True)


# Uninstall
def uninstall_runtime(repo, args):
    """Function to remove a runtime from both the local disk checkout, and the local repo"""
    # Check if runtime is checked out
    FLAG_DIREXISTS = False
    FLAG_REFEXISTS = False
    remote, runtime = disambiguate_runtime(repo, args.UNINSTALL, installed=True)
    DATADIR = f"{os.getenv('HOME')}/.var/org.mardi.maps/{remote}/{runtime}"
    if VERBOSE:
        print(f"Trying to remove {remote}:{runtime}...")
    if os.path.isdir(DATADIR):
        FLAG_DIREXISTS = True
        if VERBOSE:
            print("Deleting files...")
            opts = '-rvf'
        else:
            opts = '-rf'
        subprocess.run(f"rm {opts} {DATADIR}".split(), check=True)

    for sruntime in repo.list_refs()[1].keys():
        if runtime in sruntime:
            FLAG_REFEXISTS = True
            remote = None
            if VERBOSE:
                print("Marking branch for deletion from repo...")
            repo.set_ref_immediate(remote, runtime, None, None)
            if VERBOSE:
                print("Pruning repo...")
            repo.prune(OSTree.RepoPruneFlags(2), -1, None)
            break

    if not (FLAG_DIREXISTS and FLAG_REFEXISTS):
        print(f"Error, {args.UNINSTALL} isn't deployed and thus cannot be uninstalled!")
    else:
        print(f"Uninstalled {runtime} !")

    sys.exit()


def validate_runtime_name(runtime_id: str):
    """
    Function to validate that a given runtime ID conforms to naming rules
    """
    if VERBOSE:
        print("Validating runtime name...")
    # name must be split into name/platform/version
    # so, slash split string must have length 3
    assert len(runtime_id.split('/')) == 3, "Must have 3 parts in runtime identifier"
    if VERBOSE:
        print("Name has 3 parts separated with '/'!")

    # first part must be in rDNS. For now, it means that dot split string must have length
    # greater than or equal to 3. most commonly, it will be 3
    assert len(runtime_id.split('/')[0].split('.')) >= 3, "First part must be in reverse DNS format"
    if VERBOSE:
        print("First part is in rDNS!")

    # validate platform. for now, only x86_64 is supported
    assert runtime_id.split('/')[1] == 'x86_64'
    if VERBOSE:
        print(f"Platform is '{runtime_id.split('/')[1]}'!")
        print("Name validated!")


# Update
def mode_update(repo, repopath, args, remote=""):
    """Function to update a runtime identifier to its recent version (if any)"""
    if not args.UPDATE:
        args.UPDATE = args.DEPLOY
    # check if ref is installed
    if remote == "":
        remote, runtime = disambiguate_runtime(repo, args.UPDATE, installed=True)
    else:
        runtime = args.UPDATE.split(':')[-1]
    installed = runtime in [key.split(':')[-1] for key in repo.list_refs()[1].keys()]
    if VERBOSE:
        print(f"List of installed runtimes is {repo.list_refs()[1].keys()}")
    if not installed:
        print(f"{runtime} is not installed, hence cannot be updated! Try --deploy instead")
        return 1

    # check if we need an update
    same = repo.list_refs()[1][f'{remote}:{runtime}'] ==\
        repo.remote_list_refs(remote)[1][runtime]
    if VERBOSE:
        print(f"Local refhash = {repo.list_refs()[1][f'{remote}:{runtime}']}")
        print(f"Remote refhash = {repo.remote_list_refs(remote)[1][runtime]}")
    if same:
        print(f"{runtime} is already up to date, refreshing!")
    else:
        # download the update
        download(repopath, remote, runtime)

    DATADIR = f"{os.getenv('HOME')}/.var/org.mardi.maps/{remote}/{runtime}"

    # clean out the data dir
    if VERBOSE:
        opts1 = "-rvf"
    else:
        opts1 = "-rf"
    subprocess.run(f"rm {opts1} {DATADIR}/rofs".split(), check=True)

    # checkout branch to tree
    refhash = repo.remote_list_refs(remote)[1][runtime]
    tfd = os.open(DATADIR, os.O_RDONLY)
    osopts = blank_options()
    osopts.bareuseronly_dirs = True
    osopts.mode = OSTree.RepoCheckoutMode(1)
    if VERBOSE:
        print(f"Checking out tree from repo to {DATADIR}/rofs ...")
    repo.checkout_at(osopts, tfd, "rofs", refhash, None)

    print(f"Success... {args.DEPLOY} is now updated!")

    return 0


def checkout(repo, runtime):
    """Function to checkout an already fetched runtime from the OSTREE repository to filesystem."""
    if ':' in runtime:
        remote, runtime = runtime.split(':')
    else:
        remote = "Official"
    DATADIR = f"{os.getenv('HOME')}/.var/org.mardi.maps/{remote}/{runtime}"
    PDATADIR = '/'.join(DATADIR.split('/')[0:-1])
    refhash = ""
    for remote in repo.remote_list():
        if runtime in repo.remote_list_refs(remote)[1]:
            refhash = repo.remote_list_refs(remote)[1][runtime]
    if refhash == "":
        # refhash was not found in remote_list (obviously)
        refhash = repo.list_refs()[1][runtime]

    if VERBOSE:
        print("Setting up directories...")
        opts1 = '-pv'
    else:
        opts1 = '-p'
    subprocess.run(f"mkdir {opts1} {PDATADIR}".split(), check=True)
    subprocess.run(f"mkdir {opts1} {DATADIR}", shell=True, check=True)
    subprocess.run(f"mkdir {opts1} {DATADIR}/rwfs".split(), check=True)
    subprocess.run(f"mkdir {opts1} {DATADIR}/tmpfs".split(), check=True)

    # checkout from local repo
    tfd = os.open(DATADIR, os.O_RDONLY)
    osopts = blank_options()
    osopts.bareuseronly_dirs = True
    osopts.mode = OSTree.RepoCheckoutMode(1)
    if VERBOSE:
        print(f"Checking out tree from repo to {DATADIR}/rofs ...")
    repo.checkout_at(osopts, tfd, "rofs", refhash, None)


# Deploy Mode
def mode_deploy(repo, repopath, args):
    """Function to deploy from repo to local disk"""

    remote, runtime = disambiguate_runtime(repo, args.DEPLOY, installed=False)

    # check that runtime exists in remote
    if runtime in make_remote_ref_list(repo, remote):
        pass
    elif runtime in list(repo.list_refs()[1].keys()):
        refhash = repo.list_refs()[1][args.DEPLOY]
    else:
        print("Error: runtime not found! Use list mode --list to view available runtimes.")
        sys.exit(1)

    DATADIR = f"{os.getenv('HOME')}/.var/org.mardi.maps/{remote}/{runtime}"

    # check if update
    if os.path.exists(DATADIR):
        print("Directory already exists, trying to update...")
        if VERBOSE:
            print(f"Data directory is {DATADIR}")
        ret = mode_update(repo, repopath, args, remote=remote)
        if ret == 1:
            raise AssertionError("Error: Unknown error!")
        return

    # download
    for remote in repo.remote_list():
        if args.DEPLOY in repo.remote_list_refs(remote)[1]:
            refhash = repo.remote_list_refs(remote)[1][args.DEPLOY]
            if VERBOSE:
                print(f"Downloading {refhash}...")
            download(repopath, remote, args.DEPLOY)
            break

    # setup directories
    checkout(repo, args.DEPLOY)
    print(f"Success... {args.DEPLOY} is now ready to use!")


def blank_options():
    """Return an OSTree.RepoCheckoutAtOptions object,
    with all (most) options blanked out explicitly """
    opts = OSTree.RepoCheckoutAtOptions()
    opts.bareuseronly_dirs = False
    # opts.devino_to_csum_cache =
    opts.enable_fsync = False
    opts.enable_uncompressed_cache = False
    # opts.filter =
    # opts.filter_user_data =
    opts.force_copy = False
    opts.force_copy_zerosized = False
    opts.mode = OSTree.RepoCheckoutMode(0)
    opts.no_copy_fallback = False
    opts.overwrite_mode = OSTree.RepoCheckoutOverwriteMode(0)
    opts.process_passthrough_whiteouts = False
    opts.process_whiteouts = False
    # opts.sepolicy
    opts.sepolicy_prefix = ''
    # opts.subpath = ''
    # opts.unused_bools = []
    # opts.unused_ints = []
    # opts.unused_ptrs = []
    return opts


# Package Mode
def mode_package(repo, args):
    """Function for package mode. Not intended to be used by "end users" """
    if args.DIR is not None:
        refhash = ''
        if 'Official:base/x86_64/debian' not in list(repo.list_refs()[1].keys()):
            # import base to local repo
            if VERBOSE:
                print("base/x86_64/debian not found locally, fetching...")
            refhash = repo.remote_list_refs("Official")[1]['base/x86_64/debian']
            download(repo, "Official", "base/x86_64/debian")
        else:
            refhash = repo.list_refs()[1]['Official:base/x86_64/debian']
        with tempfile.TemporaryDirectory() as tmpdir:
            tfd = os.open(tmpdir, os.O_RDONLY)
            osopts = blank_options()
            osopts.bareuseronly_dirs = True
            osopts.mode = OSTree.RepoCheckoutMode(1)
            repo.checkout_at(osopts, tfd, "ostree", refhash, None)
            if VERBOSE:
                print("Creating directory...")
                opts = '-v'
            else:
                opts = ''
            if os.system(f"mkdir {opts} {args.DIR}") == 0:
                os.system(f"cp -r --reflink=auto {tmpdir}/ostree/* {args.DIR}/")
                print(f"Successfully initialized a base debian tree at {args.DIR} !")
            else:
                print(f"ERROR: Could not create {args.DIR}! Bailing!")
    if args.LOCATION is not None:
        # location is a functional tree, we just have to sandbox in it
        # its the user's responsibility to ensure the tree is good
        print(f"Launching a sandbox in {args.LOCATION}...")
        senv = os.environ
        senv["HOME"] = "/home/runtime"
        senv["PS1"] = "\\u@runtime:\\w# "
        senv["LC_ALL"] = "C"
        # ignore SIGINT
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        rstatus = subprocess.run((f"{BWRAP} --forward-signals --unshare-user --unshare-pid --bind "
                                  f"{args.LOCATION} / --proc /proc --dev /dev --ro-bind /sys /sys "
                                  f"--die-with-parent --uid 0 --gid 0 bash --norc").split(),
                                 env=senv, check=False)
        if VERBOSE:
            print("Exiting sandbox...")
        if rstatus.returncode != 0:
            print(f"Sandbox exited with return code {rstatus.returncode}")
        # stop ignoring SIGINT
        signal.signal(signal.SIGINT, OG_SIGINT_HANLDER)
    if args.COMMIT is not False:
        # we are given TREE and BRANCH. All we have to do is commit TREE to BRANCH
        # first validate that BRANCH follows a naming scheme we like
        validate_runtime_name(args.COMMIT[1])
        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = executor.submit(commit, [repo, args.COMMIT[0], args.COMMIT[1]])
            print(f"Committing {args.COMMIT[0]} as {args.COMMIT[1]}. Please wait...")
            while True:
                sys.stdout.write(next(SPINNER))
                sys.stdout.flush()
                time.sleep(0.2)
                sys.stdout.write('\b')
                if future.done():
                    sys.stdout.flush()
                    break
            print("Done!")
        _, refs = repo.list_refs()
        if VERBOSE:
            print("Currently available refs: ")
            print(list(refs.keys()))

    if args.UPLOAD:
        upload(repo, args.UPLOAD)


def commit(zarglist):
    """
    Function commits a tree to a repo in branch asynchronously,
    so spinner can be animated in the main thread to show activity.
    """
    repo = zarglist[0]
    tree = zarglist[1]
    branch = zarglist[2]
    if VERBOSE:
        print("\bPreparing transaction...")
    if tree[0] != '/':
        # if not an absolute pathname
        tree = f"./{tree}"
    repo.prepare_transaction()
    if VERBOSE:
        print("\bConstructing mutable tree in memory...")
    mutree = OSTree.MutableTree.new()
    if VERBOSE:
        print("\bFilling tree...")
    mfd = os.open('/'.join(tree.split('/')[0:-1]), os.O_RDONLY)
    repo.write_dfd_to_mtree(mfd, tree.split('/')[-1], mutree, None, None)
    mfile = repo.write_mtree(mutree, None)
    mcommit = repo.write_commit(None, None, None, None, mfile[1], None)
    if VERBOSE:
        print(f"\bCommitting to tree with hash {mcommit[1]}")
    repo.transaction_set_ref(None, branch, mcommit[1])
    repo.commit_transaction(None)


def reset(repo, runtime):
    """
    Function resets a runtime, simply by deleting the contents of the "rwfs" dir.
    """
    remote, runtime = disambiguate_runtime(repo, runtime, installed=True)
    DATADIR = f"{os.getenv('HOME')}/.var/org.mardi.maps/{remote}/{runtime}"
    if VERBOSE:
        print(f"Resetting {runtime}...")
        opts = '-rvf'
    else:
        opts = '-rf'
    subprocess.run(f"rm {opts} {DATADIR}/rwfs/*".split(), check=True)
    print(f"{runtime} reset successfully!")


# runtime mode: the default path for execution
def mode_runtime(repo, repopath, args):
    """
    Runtime mode, the default path for execution, and the "end user" mode.
    """
    if args.LIST:
        mode_list(repo)
    elif args.LIST_LOCAL:
        refs = list(repo.list_refs()[1].keys())
        if refs:
            for ref in sorted(refs):
                print(f"{ref.split(':')[-1]}")
    elif args.RESET:
        reset(repo, args.RESET)
    elif args.UNINSTALL:
        uninstall_runtime(repo, args)
    elif args.RUN:
        mode_run(repo, args)
    elif args.DEPLOY:
        mode_deploy(repo, repopath, args)
    elif args.UPDATE:
        mode_update(repo, repopath, args)


def byteSI(inbytes):
    """
    Given bytes, turn it into K/M/G bytes. Only kind of accurate.
    """
    scale = {0: '', 1: 'K', 2: 'M', 3: 'G'}
    exp = log10(inbytes)
    exp = int(exp / 3)
    suf = scale[exp]
    rem = inbytes / (1024 ** exp)
    return f"{rem:.2f} {suf}"


def tus_upload(filename, storage_file, runtime):
    """
    tus upload subroutine
    """
    filesize = os.path.getsize(filename)
    chunksize = 1024 * 256  # chunksize in bytes
    headers = {'Authentication': f'Basic {AUTH}', 'Tus-Resumable': '1.0.0'}
    upclient = client.TusClient(f'{TUSTARGET}/files/', headers=headers)
    storage = filestorage.FileStorage(storage_file)
    uploader = upclient.uploader(filename, store_url=True, url_storage=storage,
                                 metadata={'runtime': runtime}, chunk_size=chunksize)

    # going to need some try-catch here instead of just crashing
    # if auth or network fails
    print(f"Uploading {filename}")
    if not uploader.url:
        try:
            uploader.upload_chunk()
        except exceptions.TusCommunicationError as e:
            print("Upload failed!")
            if e.status_code is not None and e.response_content is not None:
                print(f"Error {e.status_code}: {e.response_content.decode()}")
            return False
        uploader.create_url()
        print("Created URL")

    offset = uploader.get_offset()
    uploader.offset = offset

    if VERBOSE:
        print(f"Current offset is {offset}")
        print(f"Total file size is {filesize}")
        print("=================")

    progressBar = Bar("Uploading", max=floor(filesize / chunksize))
    progressBar.suffix = '%(percent).1d%%'
    progressBar.index = int(offset / chunksize)
    progressBar.start()
    progressBar.update()
    acc = 0
    while offset < filesize:
        told = time.time()
        uploader.upload_chunk()
        tnew = time.time()
        rate = chunksize / (tnew - told)
        if acc == 0:
            progressBar.suffix = f'%(percent).1d%% | %(eta)ds remaining | {byteSI(rate)}B/s'
        acc = acc + 1
        if acc == 1000:
            progressBar.suffix = f'%(percent).1d%% | %(eta)ds remaining | {byteSI(rate)}B/s'
            acc = 1
        offset = uploader.offset
        progressBar.next()
    progressBar.finish()

    return 0


def needs_tar(refhash, tarpath, datadir):
    """
    Given a repo and a runtime, function checks if a hash for that runtime already exists.
    If the hash already exists, it returns false (i.e, we don't need to tar the runtime).
    Otherwise, it returns true.
    """
    tardbpath = f"{datadir}/tardb.toml"
    if not os.path.isfile(tarpath):
        if VERBOSE:
            print("Tarfile doesn't already exist. Needs tar-ing!")
        return True
    if VERBOSE:
        print(f"Generting a has for tarfile {tarpath}")
    tarhash = subprocess.check_output(["md5sum", tarpath]).decode().split()[0]
    if VERBOSE:
        print(f"Tar's hash is {tarhash}")
    if not os.path.isfile(tardbpath):
        # db didn't exist, clearly needs tar
        # also needs creating db
        if VERBOSE:
            print(f"Hash db not found! Creating at {tardbpath}")
            print(f"Writing hash to db for {tarpath}")
        with open(tardbpath, 'w', encoding="ascii") as tardbfile:
            tardbfile.write(f'"{refhash}"="{tarhash}"\n')
        return True
    with open(tardbpath, 'rb') as tardbfile:
        x = tomli.load(tardbfile)
        if refhash in x.keys():
            if x[refhash] == tarhash:
                if VERBOSE:
                    print("Hash found in db!")
                return False
    if VERBOSE:
        print("Hash not found in DB. We need to retar.")
    return True


def add_hash_to_db(refhash, tarpath, datadir):
    """
    Adds the md5hash of tarpath to tardb
    """
    tardbpath = f"{datadir}/tardb.toml"
    tarhash = subprocess.check_output(["md5sum", tarpath]).decode().split()[0]
    with open(tardbpath, 'a', encoding="ascii") as tardbfile:
        # assuming nobody has written a line without '\n' to the file
        tardbfile.write(f'"{refhash}"="{tarhash}"\n')


def upload(repo, runtime):
    """
    Given a local runtime, tar it and upload it. (Try)
    """
    if AUTH is None:
        raise AssertionError("MTDAUTH not set! Cannot upload without authentication!")
    # just to be sure
    # second name validation right before upload
    validate_runtime_name(runtime)
    runtimes = list(repo.list_refs()[1].keys())
    if VERBOSE:
        print("Available local runtimes are:")
        for i in runtimes:
            print(i)
    if runtime not in runtimes:
        print("We only allow publishing locally made runtimes!")
        sys.exit(1)

    DATADIR = f"{os.getenv('HOME')}/.var/org.mardi.maps"
    RUNTIMEDIR = f"{DATADIR}/{runtime}"
    TARPATH = f"{DATADIR}/{runtime}.tar.gz"
    STORAGEFILE = f"{DATADIR}/tustorage"
    REFHASH = repo.list_refs()[1][runtime]

    # if runtime is not checked out, do it
    if not os.path.isdir(RUNTIMEDIR):
        checkout(repo, runtime)

    # if the refhash matches tar hash, don't re-tar
    if needs_tar(REFHASH, TARPATH, DATADIR):
        if VERBOSE:
            print("Making tarball...")
            opts = "-cvzf"
        else:
            opts = "-czf"

        subprocess.run(f"tar {opts} {TARPATH} {RUNTIMEDIR}".split(), check=True)
        add_hash_to_db(REFHASH, TARPATH, DATADIR)

    if tus_upload(TARPATH, STORAGEFILE, runtime) != 0:
        print("something very bad happened")
        return -1

    return 0


# Main function
def main():
    """Main function"""
    # is modifying argv evil ?
    # if no "mode" is specified
    if ("runtime" not in sys.argv) and ("remote" not in sys.argv) and ("package" not in sys.argv):
        # if you're not just asking for help or version
        if "-h" in sys.argv:
            pass
        elif "--help" in sys.argv:
            pass
        elif "--version" in sys.argv:
            pass
        elif len(sys.argv) == 1:
            pass
        else:
            sys.argv.insert(1, "runtime")
    parsers = addCLI()
    parser = parsers[0]
    args = parser.parse_args()

    # Some sanity checks
    sanity_checks(parsers)

    global VERBOSE
    VERBOSE = args.VERBOSE

    # Setup
    if os.getenv('XDG_DATA_HOME') is not None:
        data = os.getenv('XDG_DATA_HOME')
    else:
        # this will crash if HOME is not set. How likely?
        data = f"{os.getenv('HOME')}/.local/share"
    data = f"{data}/org.mardi.maps"
    if args.REPO is None:
        repopath = f"{data}/ostree/repo"
    else:
        repopath = args.REPO

    repo = program_init(repopath)

    # Run mode
    if args.SubPars_NAME == 'runtime':
        mode_runtime(repo, repopath, args)
    elif args.SubPars_NAME == 'remote':
        mode_remotes(repo, args)
    elif args.SubPars_NAME == 'package':
        mode_package(repo, args)
    else:
        raise ValueError("Impossible case!")


if __name__ == "__main__":
    main()
